![Banner](https://user-images.githubusercontent.com/104200268/233587636-d6d4ee91-62ee-42c5-87b9-a5accaf33c97.PNG)
<p align="center">

 <i>GrimmaFloodfighters</i> is a real-time strategy game that demonstrates the successful integration of open geodata for disaster simulation. The city model in the game is based on publicly available geodata for the Saxony city of Grimma, where players can use floodfighter units, sandbags, boats, and emergency vehicles to rescue people and combat flood-related effects. The city model provides real-time thematic information to the emergency forces, making it a useful tool for disaster preparedness training.
 <!-- GrimmaFloodfighters is a real-time strategy game that integrates open geodata for disaster simulation. Based on publicly available geodata for Grimma, players can utilize floodfighter units, sandbags, boats, and emergency vehicles to rescue people and combat flood-related effects. -->
</p>         

<br>

<div align="center">
 
 `Unity`
 `C#`
 `UnityCollab`
 `Rider`
 `Blender`
 `Krita`
 `Geodata`
  

</div>

---

<p>

 <img align="left" width="53%" height="auto" src="https://user-images.githubusercontent.com/104200268/230764988-25ede94c-ac1d-4e1a-b506-74f9dc4e0c7a.gif">
 <br>
 <h1>About</h1>
 <li><b>Role:</b>&emsp;&emsp;&emsp;&emsp;UI/UX Designer, Programmer</li>
 <li><b>Duration:</b>&emsp;&emsp;2 Months</li>
 <li><b>Group Size:</b>&emsp;4</li>
 <li><b>Engine:</b>&emsp;&emsp;&nbsp;&nbsp;&nbsp;Unity</li>
 <li><b>Genre:</b>&emsp;&emsp;&emsp;&nbsp;Real-Time Strategy, Simulation</li>
 <li><b>Platform:</b>&emsp;&emsp;PC</li>
 <li><b>Context:</b>&emsp;&emsp;&nbsp;Open Real Time Games Workshop</li>
</p>

<br>

<p>
 <div>
 <img align="right" width="50%" height="auto" src="https://user-images.githubusercontent.com/104200268/230765192-b39e46c4-72d7-4557-a428-2d2454f0a9c4.gif">
 <br>
 <h1>Responsibilities</h1>
 <li>Geodata Integration</li>
 <li>Buildingdata Integration</li>
 <li>UI Implementation</li>
 <li>Eventlog Implementation</li>
 <li>UI Elements Creation</li>
 <li>Menu/Results Implementation</li>
 <br>
 </div>
</p>
 
<p>
 <div>
 <img align="left" width="53%" height="auto" src="https://user-images.githubusercontent.com/104200268/230765319-bf96018e-9f80-4d79-82e5-7787b9bc4b29.gif">
 <br>
 <br>
 <h1>Features</h1>
 <li>Flood Simulation</li>
 <li>Ressource Management</li>
 <li>Different Units</li>
 <li>Real Geodata</li>
 <li>Multiple Events</li>
 <li>Selfmade UI Elements</li>
 </div>
</p>

<br>
<br>

---


 <a href="https://www.youtube.com/watch?v=0X8kur32egw&ab_channel=LukasPichler" target="_blank"><img src="https://user-images.githubusercontent.com/104200268/230765521-6a3f6012-fe9d-456b-9aa7-8c7365a576cf.PNG" 
alt="Watch Trailer on YouTube" align="right" width="60%" height="auto" border="10" /></a>
<br>
 <br>
  <br>
<div align="center"> Klick on the Image on the right or the button below to watch the Trailer on YouTube! 
<br>
<br>

 
[![Watch Trailer on YouTube](https://img.shields.io/badge/Watch%20Trailer-FF0000?logo=youtube&style=for-the-badge)](https://www.youtube.com/watch?v=0X8kur32egw&ab_channel=LukasPichler) 

</div>

<br>
<br>


---

<p>
<h1>Additional Information</h1>

<h2>Feature Descriptions</h2>

<details>
 <summary>Towers</summary>
 <br>
 
 > <div align="center">
 > The game includes various towers, each with unique abilities that players can pick up, move around, place strategically, and upgrade. Currently, there exist two distinct types of towers. 
 > The ElectroTower, launches projectiles at enemies to cause damage. 
 > <br>
 > <img width="80%" height="auto" src="https://user-images.githubusercontent.com/104200268/230766835-b87e7a1a-8f41-4769-943c-2bda2dcc3b09.gif">
 > <br>
 > <br>
 > Another tower available in the game is the SpeedBuffTower. When players are within its range, they receive a temporary increase in movement speed. However, this buff slowly diminishes once they move out of the tower's range. To indicate the buff's presence, particle effects appear around the players' feet.
 > <br>
 > <img width="80%" height="auto" src="https://user-images.githubusercontent.com/104200268/230766837-7f5e5f79-af3c-4738-b6a6-315a465b65ca.gif">
 > </div>
 > <br>
 
</details> 
<details>
 <summary>Collect Coins</summary>
 <br>
 
 > <div align="center">
 >  In the game, players can gather coins by simply running over them. The collected coins are required for upgrading the towers in the game.
 > <br>
 > <img width="80%" height="auto" src="https://user-images.githubusercontent.com/104200268/230766841-c04e7d75-4396-4502-a363-d651a71fc7c5.gif">
 > </div>
 > <br>
 
</details> 
<details>
 <summary>Upgrades</summary>
 <br>
 
 > <div align="center">
 >  Once players have collected sufficient coins, they can upgrade their towers by placing them on the designated upgrade field.
 > <br>
 > <img width="80%" height="auto" src="https://user-images.githubusercontent.com/104200268/230766894-834dad10-084a-4010-a119-0966806a49a7.gif">
 > <br>
 > <br>
 > The game offers various types of upgrades, such as increasing the tower's range or the damage dealt by its projectiles. Players can select a specific upgrade by clicking on the corresponding option.
 > <br>
 > <img width="80%" height="auto" src="https://user-images.githubusercontent.com/104200268/230766877-5784bcdd-7b3e-4bda-889b-89b1bd8c3c2e.gif">
 > <br>
 > <br>
 >  Once the upgrades are complete, players can pick up their towers and strategically place them on the map. The following gif displays a fully upgraded tower in action.
 > <br>
 > <img width="80%" height="auto" src="https://user-images.githubusercontent.com/104200268/230766885-17366d5d-17ea-4ade-8657-a2aa82306d96.gif">
 > </div>
 > <br>
 
</details> 
<details>
 <summary>Local Multiplayer</summary>
 <br>
 
 > <div align="center">
 > In the game, players can collaborate and divide responsibilities to enhance their gameplay. For instance, one player can focus on moving and placing the towers while the other player collects coins to fund upgrades.
 > <img width="80%" height="auto" src="https://user-images.githubusercontent.com/104200268/230766902-424a0e98-cc68-4088-86f0-2f86f8d5a425.gif">
 > <br>
 > <br>
 > The players can interact with the towers differently, and the corresponding key required for interaction is displayed above the tower.
 > <br>
 > <img width="80%" height="auto" src="https://user-images.githubusercontent.com/104200268/230766896-ea3e574d-2b79-422a-88f5-0fc5b0cd174a.gif">
 > </div>
 > <br>
 
</details> 
<details>
 <summary>Enemies</summary>
 <br>

 >  <div align="center">
 >  The game features various types of enemies, each possessing unique attributes. These include the Base enemy, which has average health and speed compared to the others; the Speedy enemy, which is small and fast; the Tanky enemy, which is slow and has high health; and the Boss enemy, which is extremely slow and has significant health.
 >  <br>
 >  <img width="80%" height="auto" src="https://user-images.githubusercontent.com/104200268/229503757-9235d158-c451-4a0a-9e74-95f9fdb5c774.gif">
 >  <br>
 >  <br>
 >  The enemies spawn from a green glowing portal or mist and begin moving along the designated path.
 >  <br>
 >  <img width="90%" height="auto" src="https://user-images.githubusercontent.com/104200268/230767976-8d8998ef-3519-46fe-8e33-c127c37fe211.gif">
 >  </div>
 >  <br>
 
</details> 
<h2>Code Snippets</h2>

<details>
 <summary>The SpawnManager script handles the Wavemanagement</summary>
 
 > ```csharp
 > 
 > public class SpawnManager : MonoBehaviour
 > {
 >     [System.Serializable]
 >     private class EnemyToSpawn
 >     {
 >         public int enemyId;
 >         public float secondsUntilSpawn;
 >         public int spawnpointId;
 >     }
 >
 >     [System.Serializable]
 >     private class Wave
 >     {
 >         public float secondsUntilStart;
 >         public List<EnemyToSpawn> enemiesToSpawn = new List<EnemyToSpawn>();
 >     }
 >
 >     [SerializeField] private Transform parentOfEnemies;
 >
 >     [SerializeField] private EnemyMovementManager movementManager;
 >
 >     [SerializeField] private List<GameObject> spawnPoints = new List<GameObject>();
 >
 >     [SerializeField] private List<GameObject> enemies = new List<GameObject>();
 >
 >     [SerializeField] private List<Wave> waves = new List<Wave>();
 >
 >     [SerializeField] float countdown;
 >
 >     GameObject currentEnemyToSpawn;
 >     GameObject currentSpawnPoint;
 >     int nextEnemyToSpawnId;
 >     int currentWaveId;
 >     bool finished = false;
 >
 >     private void Awake()
 >     {
 >         if (waves.Count > 0)
 >         {
 >             if (waves[0].enemiesToSpawn.Count > 0)
 >             {
 >                 countdown = waves[0].secondsUntilStart + waves[0].enemiesToSpawn[0].secondsUntilSpawn;
 >                 currentEnemyToSpawn = enemies[waves[0].enemiesToSpawn[0].enemyId];
 >                 currentSpawnPoint = spawnPoints[waves[0].enemiesToSpawn[0].spawnpointId];
 >                 nextEnemyToSpawnId = 1;
 >                 currentWaveId = 0;
 >             }
 >             else
 >             {
 >                 Debug.Log("List of enemies to spawn is empty!");
 >             }
 >         }
 >         else
 >         {
 >             Debug.Log("List of waves is empty!");
 >         }
 >     }
 >
 >     void Update()
 >     {
 >         if (!finished)
 >         {
 >             countdown -= Time.deltaTime;
 >             if (countdown <= 0)
 >             {
 >                 HandleWave();
 >             }
 >         }
 >     }
 >
 >     private void HandleWave()
 >     {
 >         //if current wave has no more enemies, set next wave and reset enemyToSpawn
 >         if (nextEnemyToSpawnId >= waves[currentWaveId].enemiesToSpawn.Count)
 >         {
 >             if (currentWaveId + 1 >= waves.Count)
 >             {
 >                 finished = true;
 >             }
 >             else
 >             {
 >                 currentWaveId++;
 >                 nextEnemyToSpawnId = 0;
 >                 countdown = waves[currentWaveId].secondsUntilStart;
 >                 SpawnEnemy();
 >             }
 >         }
 >         else
 >         {
 >             SpawnEnemy();
 >         }
 >     }
 >
 >     /*
 >      * Spawns currentEnemyToSpawn at currentSpawnPoint
 >      * Sets countdown, currentEnemyToSpawn and currentSpawnPoint to next in enemiesToSpawn
 >      * Sets finished to true if the end of the list is reached
 >      */
 >     private void SpawnEnemy()
 >     {
 >         //Spawn Enemy at SpawnPoint
 >         currentEnemyToSpawn.transform.position = currentSpawnPoint.transform.position;
 >         GameObject instantiatedEnemie = Instantiate(currentEnemyToSpawn,parentOfEnemies);
 >
 >         //Move Enemy
 >         EnemyMovementSubscriber instantsOfMovement = instantiatedEnemie.GetComponent<EnemyMovementSubscriber>();
 >         instantsOfMovement.Pathnr = spawnPoints.IndexOf(currentSpawnPoint);
 >         instantsOfMovement.MovementManager = movementManager;
 >         instantsOfMovement.Subscribe();
 >
 >         //check if endOfList is reached 
 >         if (nextEnemyToSpawnId >= waves[currentWaveId].enemiesToSpawn.Count)
 >         {
 >             Debug.Log("No enemies in this wave.");
 >         }
 >         //else update variables
 >         else
 >         {
 >             EnemyToSpawn nextEnemy = waves[currentWaveId].enemiesToSpawn[nextEnemyToSpawnId];
 >             countdown += nextEnemy.secondsUntilSpawn;
 >             if (enemies.Count > nextEnemy.enemyId)
 >             {
 >                 currentEnemyToSpawn = enemies[nextEnemy.enemyId];
 >             }
 >             else
 >             {
 >                 Debug.Log("Id of next enemy to spawn greater than the size of the list of enemies.");
 >             }
 >             if (spawnPoints.Count > nextEnemy.spawnpointId)
 >             {
 >                 currentSpawnPoint = spawnPoints[nextEnemy.spawnpointId];
 >             }
 >             else
 >             {
 >                 Debug.Log("Id of next spawnPoint greater than the size of the list of spawnPoints.");
 >             }
 >             nextEnemyToSpawnId++;
 >         }
 >     }
 > }
 > ```
</details>
 <details>
 <summary>Editortool to increase Coins during Runtime to test Upgrades</summary>
 
 > ```csharp
 > 
 > public class CoinIncrease : EditorWindow
 > {
 >     int coinCount = 0;
 >
 >     [MenuItem("Tools / Add Coins")]
 >     public static void ShowWindow()
 >     {
 >         EditorWindow.GetWindow(typeof(CoinIncrease));
 >     }
 >
 >     private void OnGUI()
 >     {
 >         GUILayout.Label("Base Settings", EditorStyles.boldLabel);
 >         coinCount = EditorGUILayout.IntField("Coin Count", coinCount);
 >         GUI.backgroundColor = Color.red;
 >
 >         GUILayout.FlexibleSpace();
 >         EditorGUILayout.BeginHorizontal();
 >         GUILayout.FlexibleSpace();
 > 
 >         if(GUILayout.Button("Reset", GUILayout.Width(100), GUILayout.Height(30)))
 >         {
 >             reset();
 >         }
 >
 >         if (GUILayout.Button("Apply", GUILayout.Width(100), GUILayout.Height(30)))
 >         {
 >             CoinBag.IncreaseCoinCount(coinCount);
 >             reset();
 >         }
 >
 >         EditorGUILayout.EndHorizontal();
 >     }
 >
 >     private void reset()
 >     {
 >         coinCount = 0;
 >     }
 > }
 >
 > ```
</details>
 
<h2>Game Design Process</h2>
<details>
 <summary>Story</summary>
 <br>
 
 >  <div align="center">
 >  The story of the game evolves around two dwarf friend engineers that visit their home island and discover that it was run over by an evil force that controlls undead. They start their adventure to collect mechanical parts to construct a big robot that should protect the island. On their jouney they need to defeat different enemies and help bewohners to get to the parts.
 >  <img width="80%" height="auto" src="https://user-images.githubusercontent.com/104200268/229501634-84a928f9-61c4-413d-9cd1-616d261749a8.png">
 > </div>
 > <br>
 
</details> 
<details>
 <summary>Gameplay</summary>
 
 > <details> 
 >  <summary>Towers</summary>
 >  <div align="center">
 >  Electro Tower Before
 >  <br>
 >  <img width="90%" height="auto" src="https://user-images.githubusercontent.com/104200268/229517032-fa907571-e919-455f-9ae0-9d2885f9b976.gif">
 >  <br>
 >  Electro Tower After
 >  <br>
 >  <img width="90%" height="auto" src="https://user-images.githubusercontent.com/104200268/229517170-927ce515-75e3-4a05-a1cb-adbf21cfc0f6.gif">
 >  <br>
 >  Speed Tower Before
 >  <br>
 >  <img width="90%" height="auto" src="https://user-images.githubusercontent.com/104200268/229516308-b7b7e6b4-65df-406a-a560-cf7fe25a60c1.gif">
 >  <br>
 >  Speed Tower After
 >  <br>
 >  <img width="90%" height="auto" src="https://user-images.githubusercontent.com/104200268/229505972-6821954c-7049-4531-aa9f-0194f42ef641.gif">
 >  </div>
 >  <br>
 > </details>
 
 > <details> 
 >  <summary>Player-Tower Interaction</summary>
 >  <div align="center">
 >  In the game, players can pick up and place towers by pressing the corresponding key that appears on their screen. As it is a local multiplayer game, the key required for interaction varies depending on the player.
 >  <br>
 >  <img width="90%" height="auto" src="https://user-images.githubusercontent.com/104200268/229515511-1569be7d-8551-41d0-93f8-833a62f2ff9c.gif">
 >  </div>
 >  <br>
 > </details>
 > <details> 
 >  <summary>Collect Coins</summary>
 >  <div align="center">
 >  Players can gather coins by simply running over them, which can then be utilized to purchase upgrades for their towers.
 >  <br>
 >  <img width="90%" height="auto" src="https://user-images.githubusercontent.com/104200268/229505912-eed1e5df-42a1-4cf4-830d-ad9d248848bb.gif">
 >  </div>
 >  <br>
 > </details>
 
</details> 
<details> 
 <summary>Tools</summary>
 
 > <details> 
 >  <summary>Enemy Prefab Creation</summary>
 >  <div align="center">
 >  <br>
 >  The game development tool simplifies the process of creating new enemies by allowing for the configuration of all essential variables in a single window. If not specified, the tool automatically creates a prefab variant with default values. Developers can select a name and input their desired values for the new enemy, and the tool will adjust the variables in the scripts accordingly, producing a new prefab variant of the base enemy with the altered values.
 >  <br>
 >  <img width="70%" height="auto" src="https://user-images.githubusercontent.com/104200268/229503608-927cfed7-3d73-4657-a142-e3d01d6c657a.png">
 >  </div>
 >  <br>
 > </deatails>
 
 > <details> 
 >  <summary>Coin Increaser</summary>
 >  <div align="center">
 >  <br>
 >  Developers can use this tool to add coins during runtime, making it ideal for testing the upgrade function without needing to collect a significant amount of coins. This can accelerate the testing process and streamline the development cycle.
 >  <br>
 >  <img width="70%" height="auto" src="https://user-images.githubusercontent.com/104200268/230770557-3e53463a-f7e6-4a99-9914-6b0d503bcc5a.png">
 >  </div>
 >  <br>
 > </details>
 
 > <details> 
 >  <summary>Wave Manager</summary>
 >  <div align="center">
 >  <br>
 >  The tool is utilized to configure enemy wave spawning for the game's various levels, allowing developers to create challenging and engaging gameplay experiences for players.
 >  <br>
 >  <img width="70%" height="auto" src="https://user-images.githubusercontent.com/104200268/229503687-a79e35d8-4ac1-4047-9ebb-5c0f7ed9c445.png">
 >  </div>
 >  <br>
 > </details>
 
 > <details> 
 >  <summary>Tower Radius Display</summary>
 >  <div align="center">
 >  <br>
 >  The tool is a valuable asset for developers, as it provides a visual representation of the range of towers. By updating the serialized radius variable, developers can quickly and easily adjust the tower range without having to change the script each time. This streamlines the development process and saves time, allowing for faster iteration and testing.
 >  <br>
 >  <img width="100%" height="auto" src="https://user-images.githubusercontent.com/104200268/230770309-c4e6a415-2113-4fe6-b184-144e43a316f1.gif">
 >  </div>
 >  <br>
 > </details>
 
 > <details> 
 >  <summary>Object Spawner</summary>
 >  <div align="center">
 >  <br>
 >  Spawns a specified number of objects with random position, rotation, and scale. It checks for collisions and allows for the addition of a parent for the objects. The engine issues a warning if critical boxes are missing and disables the button in such cases.
 >  <br>
 >  <img width="70%" height="auto" src="https://user-images.githubusercontent.com/104200268/229503592-1c498c77-49b8-434a-8c7a-d58390f9f26d.png">
 >  </div>
 >  <br>
 > </deatails>
 
</details> 
 
<details>
 <summary>Level Design Process</summary>
 <br>
 
 >  <div align="center">
 >  Initial Prototype
 >  <img width="100%" height="auto" src="https://user-images.githubusercontent.com/104200268/229474718-86156057-936e-4639-b6be-1a7d6a493a5e.png">
 >  <br>
 >  Assets
 >  <br>
 >  <img width="100%" height="auto" src="https://user-images.githubusercontent.com/104200268/229474782-e6695b85-f3e6-4623-8396-6aead4a1f96c.png">
 >  <br>
 >  Light Baking & Post Processing
 >  <br>
 >  <img width="100%" height="auto" src="https://user-images.githubusercontent.com/104200268/229475909-ef819f0a-e923-4740-a429-5398f32dfae7.png">
 >  <br>
 >  Details and VFX
 >  <br>
 >  <img width="100%" height="auto" src="https://user-images.githubusercontent.com/104200268/229474831-79b7d189-cb4f-40b7-974a-66b3c3f88579.png">
 >  <br>
 >  Level Design Decisions
 >  <br>
 >  <img width="100%" height="auto" src="https://user-images.githubusercontent.com/104200268/229474892-b776e17d-a615-4828-b3a2-87927df9e119.png">
 >  <br>
 >  <img width="100%" height="auto" src="https://user-images.githubusercontent.com/104200268/229474863-518e66ce-d1a3-4353-bbc2-cc07bb774243.png">
 >  <br>
 >  <img width="100%" height="auto" src="https://user-images.githubusercontent.com/104200268/229475961-e0ff54cf-c4d2-4bed-8c6c-75bfaab2eed1.png">
 > </div>
 > <br>
 
</details> 
</p>
